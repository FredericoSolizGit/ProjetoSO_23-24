//
// Created by so on 23-04-2024.
//
#include "requisito_4.h"
#include "requisito_3.h"
#include "requisito_2.h"
#include "monteCarlo.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/wait.h>
#include <fcntl.h>

void requisito_4(char *filename, int num_processes, int total_points_generated) {

    // input file
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("error opening file %s.\n", filename);
        return;
    }

    int n;
    fscanf(file, "%d", &n);

    Point *polygon = (Point *)malloc(n * sizeof(Point));
    if (polygon == NULL) {
        printf("error allocating memory\n");
        fclose(file);
        return;
    }

    for (int i = 0; i < n; i++) {
        fscanf(file, "%lf %lf", &polygon[i].x, &polygon[i].y);
    }

    fclose(file);

    // exit file
    int fd = open("results.txt", O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
    if (fd == -1) {
        printf("error opening exit file\n");
        free(polygon);
        return;
    }

    int pipes[num_processes][2]; // array of pipes for communication with each child

    for (int i = 0; i < num_processes; i++) {
        if (pipe(pipes[i]) == -1) {
            perror("pipe");
            free(polygon);
            close(fd);
            return;
        }
    }

    int points_per_child = total_points_generated / num_processes;
    srand(time(NULL)); // seed
    Point *random_point = (Point *)malloc(total_points_generated * sizeof(Point));
    if (random_point == NULL) {
        printf("error allocating memory\n");
        free(polygon);
        close(fd);
        return;
    }

    for (int i = 0; i < total_points_generated; i++) {
        random_point[i].x = ((double)rand() / RAND_MAX) * 2 - 1; // -1 a 1
        random_point[i].y = ((double)rand() / RAND_MAX) * 2 - 1; // -1 a 1
    }

    // child processes verify IsInside
    for (int i = 0; i < num_processes; i++) {
        int start = i * points_per_child;
        int end = start + points_per_child;
        pid_t pid = fork();
        if (pid < 0) {
            printf("fork failed\n");
            free(polygon);
            free(random_point);
            close(fd);
            return;
        } else if (pid == 0) {
            // child
            int points_inside_polygon = 0;
            for (int j = start; j < end; j++) {
                if (isInsidePolygon(polygon, n, random_point[j])) {
                    dprintf(fd, "Process id: %d; Coordenate x: %.2f; Coordenate y: %.2f\n", getpid(), random_point[j].x, random_point[j].y);
                    points_inside_polygon++;
                }
            }
            dprintf(fd, "Process id:%d; Points generated by child: %d; Points inside polygon: %d;\n", getpid(), points_per_child, points_inside_polygon);
            write(pipes[i][1], &points_inside_polygon, sizeof(int));
            close(pipes[i][1]); // closes writting side of pipe
            free(polygon);
            free(random_point);
            exit(EXIT_SUCCESS);
        }
    }

    for (int i = 0; i < num_processes; i++) {
        wait(NULL);
        printf("Progress: %d || Child %d finished\n", (i + 1) * (100/num_processes), i + 1);
        //sleep(1);
    }

    int total_points_inside_polygon = 0;
    for (int i = 0; i < num_processes; i++) {
        int points_inside_polygon;
        read(pipes[i][0], &points_inside_polygon, sizeof(int));
        total_points_inside_polygon += points_inside_polygon;
        close(pipes[i][0]); // closes reading side of pipe
    }

    double area = (double)total_points_inside_polygon / total_points_generated * 4.0;
    printf("polygon area: %f\n", area);
    close(fd);

    for (int i = 0; i < num_processes; i++) {
        close(pipes[i][0]);
        close(pipes[i][1]);
    }

    free(polygon);
    free(random_point);
}
